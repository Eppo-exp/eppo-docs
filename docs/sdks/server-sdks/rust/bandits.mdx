---
title: Contextual Bandits
sidebar_position: 5
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import ApiOptionRef from '@site/src/components/ApiOptionRef';

## Usage with Contextual Multi-Armed Bandits

Eppo also supports contextual multi-armed bandits. You can read more about them in the [high-level documentation](/contextual-bandits).
Bandit flag configuration--including setting up the flag key, status quo variation, bandit variation, and targeting rules--are configured within
the Eppo application. However, available actions are supplied to the SDK in the code when querying the bandit.

To leverage bandits using the Rust SDK, there are two additional steps over regular feature flags:
1. Add a bandit action logger to the SDK client instance
2. Query the bandit for an action

### Define a bandit assignment logger

In order for the bandit to learn an optimized policy, we need to capture and log the bandit's actions.
This requires defining a bandit logger in addition to an assignment logger.

```rust
use eppo::{AssignmentLogger, BanditLogger, AssignmentEvent, BanditEvent};

// Define an assignment logger for recording variation assignments
struct MyAssignmentLogger;

impl AssignmentLogger for MyAssignmentLogger {
    fn log_assignment(&self, assignment: AssignmentEvent) {
        println!("TODO: save assignment information to data warehouse: {:?}", assignment);
    }
}

// Define a bandit logger for recording bandit action assignments
struct MyBanditLogger;

impl BanditLogger for MyBanditLogger {
    fn log_bandit_action(&self, bandit_event: BanditEvent) {
        println!("TODO: save bandit action information to the data warehouse: {:?}", bandit_event);
    }
}

// Initialize the SDK with both loggers provided
let mut client = eppo::ClientConfig::from_api_key("<YOUR_API_KEY>")
    .assignment_logger(MyAssignmentLogger)
    .bandit_logger(MyBanditLogger)
    .to_client();

client.start_poller_thread();
```

The SDK will invoke the `log_bandit_action()` function with a `BanditEvent` struct that contains the following fields:

| Field | Type | Description | Example |
|-------|------|-------------|----------|
| `timestamp` | `String` | The time when the action is taken in UTC as an ISO string | "2024-03-22T14:26:55.000Z" |
| `feature_flag` | `String` | The key of the feature flag corresponding to the bandit | "bandit-test-allocation-4" |
| `bandit` | `String` | The key (unique identifier) of the bandit | "ad-bandit-1" |
| `subject` | `String` | An identifier of the subject or user assigned to the experiment variation | "ed6f85019080" |
| `subject_numeric_attributes` | `HashMap<String, f64>` | Metadata about numeric attributes of the subject | `{"age": 30.0}` |
| `subject_categorical_attributes` | `HashMap<String, String>` | Metadata about non-numeric attributes of the subject | `{"loyalty_tier": "gold"}` |
| `action` | `String` | The action assigned by the bandit | "promo-20%-off" |
| `action_numeric_attributes` | `HashMap<String, f64>` | Metadata about numeric attributes of the assigned action | `{"brandAffinity": 0.2}` |
| `action_categorical_attributes` | `HashMap<String, String>` | Metadata about non-numeric attributes of the assigned action | `{"previouslyPurchased": "false"}` |
| `action_probability` | `f64` | The weight between 0 and 1 the bandit valued the assigned action | 0.25 |
| `optimality_gap` | `f64` | The difference between the score of the selected action and the highest-scored action | 456.0 |
| `model_version` | `String` | Unique identifier for the version of the bandit parameters | "v123" |
| `meta_data` | `HashMap<String, String>` | Any additional freeform meta data | `{"sdkLibVersion": "0.1.0"}` |

### Querying the bandit for an action

To query the bandit for an action, you can use the `get_bandit_action()` function. This function takes the following parameters:
- `flag_key`: The key of the feature flag corresponding to the bandit
- `subject_key`: The key of the subject or user assigned to the experiment variation
- `subject_attributes`: The context of the subject
- `actions`: Available actions, optionally mapped to their respective contexts
- `default_value`: The default *variation* to return if the flag is not successfully evaluated

```rust
use std::collections::HashMap;
use eppo::{BanditActions, ContextAttributes};

let flag_key = "shoe-bandit";
let subject_key = "user123";
let subject_attributes = HashMap::from([
    ("age".to_string(), 25.into()),
    ("country".to_string(), "GB".into()),
]);
let default_value = "default";

// Define action contexts
let mut actions = BanditActions::new();
actions.insert("nike".to_string(), ContextAttributes {
    numeric_attributes: HashMap::from([
        ("brandAffinity".to_string(), 2.3)
    ]),
    categorical_attributes: HashMap::from([
        ("imageAspectRatio".to_string(), "16:9".to_string())
    ])
});
actions.insert("adidas".to_string(), ContextAttributes {
    numeric_attributes: HashMap::from([
        ("brandAffinity".to_string(), 0.2)
    ]),
    categorical_attributes: HashMap::from([
        ("imageAspectRatio".to_string(), "16:9".to_string())
    ])
});

let result = client.get_bandit_action(
    flag_key,
    subject_key,
    subject_attributes,
    actions,
    default_value,
);

match result {
    Ok(assignment) => {
        if let Some(action) = assignment.action {
            render_shoe_ad(&action);
        } else {
            render_default_shoe_ad();
        }
    },
    Err(e) => {
        eprintln!("Error getting bandit action: {:?}", e);
        render_default_shoe_ad();
    }
}
```

#### Subject context

The subject context contains contextual information about the subject that is independent of bandit actions.
For example, the subject's age or country.

The subject context can be provided as a `HashMap<String, Value>`, which will then assume anything that is a number is a numeric
attribute, and everything else is a categorical attribute.

You can also explicitly bucket the attribute types by providing the context as `ContextAttributes`. For example, you may have an attribute named `priority`, with 
possible values `0`, `1`, and `2` that you want to be treated categorically rather than numeric. `ContextAttributes` have two nested hashmaps:
- `numeric_attributes`: A mapping of attribute names to their numeric values (e.g., `age: 30.0`)
- `categorical_attributes`: A mapping of attribute names to their categorical values (e.g., `country: "US"`)

Any non-numeric values explicitly passed in as values for numeric attributes will be ignored.

Attribute names and values are case-sensitive.

:::note
The subject context, passed in as the `subject_attributes` parameter, is also still used for targeting rules for the feature flag,
just like with non-bandit assignment methods.
:::

#### Action contexts

The action context contains contextual information about each action. They can be provided as a mapping of attribute names 
to their contexts. 

Similar to subject context, action contexts can be provided as `HashMap<String, Value>`--which will then assume anything that is a number is a numeric
attribute, and everything else is a categorical attribute--or as `ContextAttributes`, which have explicit bucketing into `numeric_attributes`
and `categorical_attributes`.

Note that relevant action contexts are subject-action interactions. For example, there could be a "brand-affinity" model
that computes brand affinities of users to brands, and scores of that model can be added to the action context to provide
additional context for the bandit.

If there is no action context, a vector of strings comprising only the actions names can also be passed in.

If the subject is assigned to the variation associated with the bandit, the bandit selects one of the supplied actions.
All actions supplied are considered to be valid. If an action should not be available to a subject, do not include it for that call.

Like attributes, actions are case-sensitive.

#### Result

`get_bandit_action()` returns a `Result` containing an `Assignment` struct with two fields:
- `variation`: The variation that was assigned to the subject
- `action`: The action that was assigned to the subject by the bandit, or `None` if the bandit was not assigned

The variation returns the feature flag variation. This can be the bandit itself, or the "status quo" variation if the subject is not assigned to the bandit.

If we are unable to generate a variation, for example when the flag is turned off, then the provided `default` variation is returned.
In both of those cases, the returned `action` will be `None`, and you should use the status-quo algorithm to select an action (more on this below).

When `action` is `Some`, the bandit has selected an action for the subject.

:::note
If no actions are provided and the flag still has an active bandit, if the bandit variation is assigned the assigned
action will be `None`.
:::

:::note
If the flag no longer has any allocations with bandits, this function will behave the same as `get_string_assignment()`, with
the provided actions being ignored and the assigned variation being returned along with a `None` action.
:::

#### Status quo algorithm

In order to accurately measure the performance of the bandit, we need to compare it to the status quo algorithm using an experiment.
This status quo algorithm could be a complicated algorithm that selects an action according to a different model, or a simple baseline such as selecting a fixed or random action.
When you create an analysis allocation for the bandit and the returned `action` is `None`, implement the desired status quo algorithm based on the `variation` value.

## Debugging

You may encounter a situation where a flag assignment produces a value that you did not expect. There are functions [detailed here](/sdks/sdk-features/debugging-flag-assignment/) to help you understand how flags are assigned, which will allow you to take corrective action on potential configuration issues. 